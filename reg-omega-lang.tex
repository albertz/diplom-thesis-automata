\section{Background results on regular $\omega$-languages}

\subsection{Preliminaries}
We introduce some common terminonoly used in this thesis.

The set of natural numbers $1,2,3,\dots$ is denoted by $\N$, likewise $0,1,2,3,\dots$ by $\N_0$.

An \defword{alphabet} is a finite set of \defword{symbols}. We usually denote an alphabet by $\Sigma$ and its elements by $a, b, c, \dots$. A finite sequence of elements in $\Sigma$ is also called a \defword{finite word}, often named $u, v, w, \dots$. The set of such words, including the \defword{empty word} $\epsilon$, is denoted by $\Sigma^*$. Likewise, $\Sigma^+$ is the set of non-empty words. Infinite sequences over $\Sigma$ are called \defword{infinite words}, often named $\alpha, \beta$. The set of such infinite words is denoted by $\Sigma^\omega$.

A subset $L \subseteq \Sigma^*$ is called a \defword{language} of finite words or also called a \defword{$*$-language}. Likewise, a subset $L^\omega \subseteq \Sigma^\omega$ is called an \defword{$\omega$-language}.

A set $\Lang$ of $*$-languages is called a \defword{$*$-language class}. Likewise, a set $\Lang^\omega$ of $\omega$-languages is called a \defword{$\omega$-language class}.

We can \defword{concatenate} finite words with each other and also finite words with infinite words. For languages $L_1 \subseteq \Sigma^*$, $L_2 \subseteq \Sigma^*$, $L^\omega_3 \subseteq \Sigma^\omega$, we define the concatenation $L_1 \cdot L_2 := \Set{v \cdot w}{v \in L_1, w \in L_2}$ and $L_1 \cdot L^\omega_3 := \Set{v \cdot \alpha}{v \in L_1, \alpha \in L^\omega_3}$. Exponentation of languages is defined naturally: For $L \subseteq \Sigma^*$, we define $L^0 := \Set{\epsilon}$ and $L^{i+1} := L^i \cdot L$ for all $i \in \N_0$. The union of all such sets, is called the \defword{Kleene closure} or the \defword{Kleene star} operator, defined as $L^* := \cup_{i\in\N_0} L^i$. The \defword{positive Kleene closure} is defined as $L^+ := \cup_{i\in\N} L^i$. The \defword{infinite Kleene closure} is defined by $L^\omega := \Set{w_1 \cdot w_2 \cdot w_3 \cdots}{w_i \in L}$.

\subsection{The class of regular $*$-languages}

A \defword{regular expression} is representing a language over an alphabet $\Sigma$. Regular expressions are defined recursively based on the ground terms $\emptyset$, $\epsilon$ and $a$ for $a \in \Sigma$ denoting the languages $\emptyset$, $\Set{\epsilon}$ and $\Set{a}$. Then, if $r$ and $s$ are regular expressions representing $R, S \subseteq \Sigma^*$, then also $r+s$ (written also as $r|s$, $r \vee s$, $r \cup s$), $r s$ (written also as $r \cdot s$) and $r^*$ are regular expressions, representing $R \cup S$, $R \cdot S$ and $R^*$. Let $\Lang^*(\text{RE})$ be the set of languages which can be represented as regular expressions.

We extend these expression also by $r \wedge s$ (written also as $r \cap s$) and $-r$ (written also as $\neg r$), representing the language $R \cap S$ and $-R := \Set{w \in \Sigma^*}{w \not\in R}$. Some basic result of the study of formal languages, as can be seen in e.g. \cite{FinAutLogR109}, is the equivalence of the class of these extended regular expression languages and $\Lang^*(\text{RE})$.

A \defword{non-deterministic} \defword{finite-state automaton} $\A$ over an alphabet $\Sigma$ is given by a finite set $Q$ of \defword{states} and a subset $\Delta \subseteq Q \times \Sigma^* \times Q$ of \defword{transitions}. In most cases we also have an \defword{initial states} $q_0 \in Q$ and a subset $F \subseteq Q$ of \defword{final states}.

We write:
\[ \A = (Q, \Sigma, q_0, \Delta, F). \]

The automaton is \defword{deterministic} (a DFA) iff $\Delta$ is a function $Q \times \Sigma \rightarrow Q$. In that case, we often call the function $\delta$.

Two transitions $(p,a,q), (p',a',q') \in E$ are \defword{consecutive} iff $q=p'$.

A \defword{run} in the automaton $\A$ is a finite sequence of consecutive transitions, written as:
\[ q_0 \xrightarrow{a_0} q_1 \xrightarrow{a_1} q_2 \dots \]

An automaton $\A = (Q, \Sigma, q_0, \Delta, F)$ \defword{accepts} a finite word $w = (a_0,a_1,...,a_n) \in \Sigma^*$ iff there is a run $q_0 \rightarrow^{a_0} q_1 \rightarrow^{a_1} q_2 \dots \rightarrow^{a_n} q_{n+1}$ with $q_0 \in I$ und $q_{n+1} \in F$.

The $*$-language $L^*(\A)$ is defined as set of all finite words which are accepted by $\A$.

The set of $*$-languages accepted by a NFA is called $\Lang^*(\text{NFA})$. Likewise, $\Lang^*(\text{DFA})$ is the set of $*$-languages accepted by a DFA. A basic result (see for example \cite{FinAutLogR109} or \cite{InfWordsR110}) is
\[ \Lang^*(\text{DFA}) = \Lang^*(\text{NFA}) = \Lang^*(\text{RE}) . \]

This class of $*$-languages is called the class of \defword{regular $*$-languages}. We name it $\Langreg$ from now on.

\subsection{The class of regular $\omega$-languages}
\label{reg-omega-lang}

The class of regular $\omega$-languages can be defined in many different ways. We will use one common definition and show some equivalent descriptions.
\[ \LangOreg := \Set{ \bigcup_{i=1}^n\ U_i \cdot V_i^\omega }{ U_i, V_i \in \Langreg, n \in \N_0 } \]

This is also called the \defword{Kleene closure}.

\subsubsection{$\omega$ regular expressions}

For a regular expression $r$ representing a $*$-language $R\subseteq \Sigma^*$, we can introduce a corresponding $\omega$ regular expression $r^\omega$ which represents the $\omega$-language $R^\omega$. This $\omega$ regular expression can be combined with other $\omega$ regular expressions as usual and prefixed by standard regular expressions. We call all these combinations $\omega$ regular expressions.

We see that $\LangOreg$ is closed under union (obviously), intersection and complement.

Thus, the class of languages accepted by $\omega$ regular expressions is exactly $\LangOreg$.


\subsubsection{$\omega$-automata}

A different, very common description is in terms of automata.

An automaton $\A = (Q, \Sigma, q_0, \Delta, F)$ \defword{Büchi-accepts} an infinite word $\alpha = (a_0,a_1,a_2,...) \in \Sigma^\omega$ iff there is an infinite run $q_0 \xrightarrow{a_0} q_1 \xrightarrow{a_1} q_2 \xrightarrow{a_2} q_3 \cdots$ in $\A$ with $\Set{ i \in \N_0 }{ q_i \in F }$ infinite, i.e. which reaches a state in $F$ infinitely often.

The language $L^\omega(\A)$ is defined as the set of all infinite words which are Büchi-accepted by  $\A$. To make clear that we use the Büchi acceptance condition, we sometimes will also write $L^\omega_\text{Büchi}(\A)$.

A basic result of the study of this language class is: The set of all languages accepted by a non-deterministic Büchi automaton is exactly $\LangOreg$ (see \cite{InfCompR101} or others). %S218
Deterministic Büchi automata are less powerful, e.g. they cannot recognise $(a+b)^* b^\omega$.

There are some different forms of $\omega$-automata which differ in their acceptance condition. Noteable are the \defword{Muller conition}, the \defword{Rabin condition}, the \defword{Streett condition} and the \defword{Parity condition}. With such an acceptance condition, we call it \defword{Muller automaton}, etc. The main theorem of deterministic $\omega$-automata states:
\begin{itemize}
\item Non-deterministic Büchi automata,
\item a boolean combination of deterministic Büchi automata,
\item deterministic Muller automata,
\item deterministic Rabin automata,
\item deterministic Streett automata,
\item deterministic Parity automata
\end{itemize}
all recognize the same languages. See \cite{InfCompR101}, \cite{LangAutLogicR102}, \cite{InfWordsR110} and others. Part of it is the \defword{McNaughton's Theorem} which states the equivalence of non-deterministic Büchi automata and deterministic Muller automata.
%S407

Muller automata are interesting for us in the rest of this thesis. The acceptance component of a Muller automaton is a set $\F \subseteq 2^Q$, also called the \defword{table} of the automaton (instead of a single set $F \subseteq Q$). A word $w \in \Sigma^\omega$ is accepted iff there is an infinite run $p$ with $\Inf(p) \in \F$, where $\Inf(p)$ is the set of infinitely often reached states of the run $p$.

We write:
\[ \A = (Q, \Sigma, q_0, \Delta, \F) . \]

\subsubsection{Other language operators}

Büchi acceptance is closely connected to the language operator
\[ \lim(L) := \Set{ \alpha \in \Sigma^\omega }{ \existsinf n \colon \alpha[0,n] \in L } . \]
We define the language class operator
\[ \lim(\Lang) := \Set{\lim(L)}{L \in \Lang} . \]
We see that $\lim(\Langreg)$ is equal to the languages accepted by deterministic Büchi automata (\cite{InfCompR101}). %S407
Thus:
\[  \BC \lim \Langreg = \LangOreg , \]
where $\BC$ means all boolean combinations (union, intersection, complement).

Another classification is
\[ \LangOreg = \Set{ \bigcup_{i=0}^n U_i \cdot \lim V_i }{ U_i, V_i \in \Langreg, n \in \N_0 } . \]

\subsubsection{Logic on infinite words}
%(S218,S411,R107)
Let $L_2(\Sigma)$ be the set of formulas $\operatorname{MSO}(<)$ over $\Sigma$. The interpretation of such formulas over infinite words is straight-forward. In \cite{CombR107}, we can see that
\[ \LangOreg = \Set{A \subseteq \Sigma^\omega}{A \text{ definable in } L_2(\Sigma)} . \]

We will formulate some properties of interest in a general form for a $*$-language class $\Lang$ which all hold for $\Langreg$. We get some general results based on these properties in chapter \ref{general-results}.

Let $L,A,B \in \Lang$.
\begin{itemize}
\item E1: $L \cdot \Sigma^* \in \Lang$ (not suffix sensitive)
\item E2a: $A \cup B \in \Lang$
\item E2b: $A \cap B \in \Lang$
\item E3: $- L \in \Lang$ (closed under complementation) (S303.E3, S218, R101)

\item
%S303.1:
In some proofs, e.g. in \ref{gen:staiger-wagner} or \ref{gen:kleene-star}, we have an automaton based on some language of the language class and we do some modifications on it, e.g. we modify the final state set. If we stay in the language class, we call this the E4 property. Formally:

E4: $\forall \text{ deterministic automaton } \A = (Q,q_0,\Delta,F), L^*(\A) = L \colon \forall F' \subseteq Q: L^*((Q,q_0,\Delta,F')) \in \Lang$

For $\Langreg$, this property holds obviously.

%S303.1.a:
For $\Lang^*(\mathrm{FO[<]})$, it does not hold:

  \begin{tikzpicture}[%
    >=stealth,
	shorten >=1pt,
	node distance=2cm,
%    on grid,
    auto,
%    state/.append style={minimum size=2em},
%    thick
  ]
    \node[state] (S)              {};
    \node[state,double] (A) [right of=S] {$A$};
    \node[state] (B) [below of=S] {$B$};
    \node[state] (C) [right of=B] {};

    \path[->] (S) +(-1,0) edge (S)
              (S)         edge              node {$a$} (A)
              (S)         edge              node {$b$} (B)
              (B)         edge  [bend left]            node {$b$} (C)
              (C)         edge  [bend left]            node {$b$} (B)
              ;
  \end{tikzpicture}
  
This is a deterministic automaton for the language $\Set{a} \in \Lang^*(\mathrm{FO[<]})$. If you make $B$ also a final state, we get the language $a + b(bb)^* \not\in \Lang^*(\mathrm{FO[<]})$.

So, E4 seems too restricted.

%S303.1: TODO: weniger ...

\end{itemize}
