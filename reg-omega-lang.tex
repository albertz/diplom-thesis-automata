\section{Background results on regular $\omega$-languages}
\label{chapter:regOmegaLangs}

\subsection{Preliminaries}
We introduce some common terminology used in this thesis.

The set of natural numbers $1,2,3,\dots$ is denoted by $\N$, likewise $0,1,2,3,\dots$ by $\N_0$. The set of boolean values, also identified as $\Set{0,1}$, is denoted by $\B$. $\Power(M)$ is the set of all subsets of $M$, sometimes also written as $2^M$, defined as $\Set{S}{S \subseteq M}$. $-M$ denotes all elements which are not in $M$, defined as $\Set{x}{x \not\in M}$ (the superset of $M$ is determined by the context). We denote the cardinality of $M$ by $\#M$ or $\left| M \right|$. Likewise, for a sequence $s$ of elements which can be both infinite or finite, the length is denoted by $\#s$ or $\left|s\right|$. $s[i]$ denotes the $i$-the element from $s$. We start counting at $0$, i.e. $s[0]$ is the first element and $s[\left|s\right|-1]$ is the last element. $s[i,j]$ denotes the subsequence of $s$, starting from the $i$-th element up to the $j$-th element, both including. If $i>j$, it represents the empty sequence. If $j > \left|s\right|$, it is the subsequence $s[i,\left|s\right|]$. Given two functions $\operatorname{f} \colon X \rightarrow Y$, $\operatorname{g} \colon Y \rightarrow Z$, we often leave away parentheses and write $\operatorname{g} \operatorname{f} x$ instead of $\operatorname{g}(\operatorname{f}(x))$ as long as there is no ambiguity. $\exists n \colon P(n)$, $\forall n \colon P(n)$, $\exists^\omega n \colon P(n)$ are short for "there exists $n$ such that $P(n)$", "for all $n$, it holds $P(n)$" and "there exists infinitely many $n$ with $P(n)$" respectively, where $P(n)$ is some statements about $n$. If the domain of $n$ is not specified, the biggest domain is assumed where $P(n)$ makes sense, which is usually $\N_0$.

An \defword{alphabet} is a finite set of \defword{symbols}. We usually denote an alphabet by $\Sigma$ and its elements by $a, b, c, \dots$. A finite sequence of elements in $\Sigma$ is also called a \defword{finite word}, often named $u, v, w, \dots$. The set of such words, including the \defword{empty word} $\epsilon$, is denoted by $\Sigma^*$. Likewise, $\Sigma^+$ is the set of non-empty words. Infinite sequences over $\Sigma$ are called \defword{infinite words}, often named $\alpha, \beta$. The set of such infinite words is denoted by $\Sigma^\omega$.

A subset $L \subseteq \Sigma^*$ is called a \defword{language} of finite words or also called a \defword{$*$-language}. Likewise, a subset $\tilde L \subseteq \Sigma^\omega$ is called an \defword{$\omega$-language}.

A set $\Lang$ of $*$-languages is called a \defword{$*$-language class}. Likewise, a set $\Lang^\omega$ of $\omega$-languages is called a \defword{$\omega$-language class}.

We can \defword{concatenate} finite words with each other and also finite words with infinite words. For languages $L_1 \subseteq \Sigma^*$, $L_2 \subseteq \Sigma^*$, $\tilde L_3 \subseteq \Sigma^\omega$, we define the concatenation $L_1 \cdot L_2 := \Set{v \cdot w}{v \in L_1, w \in L_2}$ and $L_1 \cdot \tilde L_3 := \Set{v \cdot \alpha}{v \in L_1, \alpha \in \tilde L_3}$. In some cases, we might leave away the concatenation dot and just write $L_1 L_2$ or $L_1 \tilde L_3$. Exponentation of languages is defined naturally: For $L \subseteq \Sigma^*$, we define $L^0 := \Set{\epsilon}$ and $L^{i+1} := L^i \cdot L$ for all $i \in \N_0$. The union of all such sets, is called the \defword{Kleene star} operator, defined as $L^* := \cup_{i\in\N_0} L^i$. The \defword{positive Kleene star} is defined as $L^+ := \cup_{i\in\N} L^i$. The \defword{$\omega$-Kleene star} is defined by $L^\omega := \Set{w_1 \cdot w_2 \cdot w_3 \cdots}{w_i \in L, w_i \ne \epsilon}$.

\subsection{The class of regular $*$-languages}
\label{intro:reglang}

The class of regular $*$-languages is probably the most well-studied class of languages. In the study of formal language theorey, Stephen Cole Kleene introduced this class via \defword{regular sets} in \cite{Kleene56}.

A \defword{regular expression} is representing such a regular set. It represents a language over an alphabet $\Sigma$. Regular expressions are defined recursively based on the ground terms $\emptyset$, $\epsilon$ and $a$ for $a \in \Sigma$ denoting the languages $\emptyset$, $\Set{\epsilon}$ and $\Set{a}$. Then, if $r$ and $s$ are regular expressions representing $R, S \subseteq \Sigma^*$, then also $r+s$ (written also as $r|s$, $r \vee s$, $r \cup s$), $r s$ (written also as $r \cdot s$) and $r^*$ are regular expressions, representing $R \cup S$, $R \cdot S$ and $R^*$. Let $\Lang^*(\text{RE})$ be the set of languages which can be represented as regular expressions.

\begin{simpleexample}
$a(a+b)^*bb$ is a regular expression representing the language $\Set{a} \cdot \Set{a,b}^* \cdot \Set{bb}$.
\end{simpleexample}

We extend these expressions also by $r \wedge s$ (written also as $r \cap s$) and $-r$ (written also as $\neg r$), representing the language $R \cap S$ and $-R := \Set{w \in \Sigma^*}{w \not\in R}$. Some basic result of the study of formal languages, as can be seen in e.g. \cite{FinAutLogR109}, is the equivalence of the class of these extended regular expression languages and $\Lang^*(\text{RE})$.

Regular languages are also strongly connected to finite-state automata. These are a theoretical description of a machine having a finite number of internal states. These automata operate on a discrete set of input symbols and can change the internal state with each input symbol. Because the number of states is finite, these are strictly less powerful than Turing machines, which have an infinite number of states given by the infinite memory. S.C. Kleene proved in \cite{Kleene56} that finite automata can express exactly the class of regular languages. A first generic definition of such automata was given in \cite{FinAutRabin59}.

Also defined first by \cite{FinAutRabin59} is the \defword{non-deterministic} \defword{finite-state automaton} (NFA) $\A$ over an alphabet $\Sigma$. Formally, such NFA $\A$ is defined by a finite set $Q$ of \defword{states} and a subset $\Delta \subseteq Q \times \Sigma \times Q$ of \defword{transitions}. In most cases we also have an \defword{initial state} $q_0 \in Q$ and a subset $F \subseteq Q$ of \defword{final states}.

We write:
\[ \A = (Q, \Sigma, q_0, \Delta, F). \]

A common way to draw such automaton is via a transition graph.
\begin{simpleexample}
\label{reg:nfa-example-1}
Let $\Sigma := \Set{a,b}$, $Q := \Set{0,1,2,3}$, $q_0 := 0$,
\[ \Delta := \Set{ (0,a,1), (1,a,1), (1,b,1), (1,b,2), (2,b,3) } \]
and $F := \Set{3}$. Then we can draw $\A := (Q,\Sigma,q_0,\Delta,F)$ as:
\[
  \begin{tikzpicture}[%
    >=stealth,
	shorten >=1pt,
	node distance=2cm,
    auto,
  ]
    \node[state] (0)              {$0$};
    \node[state] (1) [right of=0] {$1$};
    \node[state] (2) [right of=1] {$2$};
    \node[state,double] (3) [right of=2] {$3$};

    \path[->]
    (0) +(-1.5,0) edge (0)
    (0) edge node {$a$} (1)
    (1) edge [loop above] node {$a,b$} ()
    (1) edge node {$b$} (2)
    (2) edge node {$b$} (3)
    ;
  \end{tikzpicture}
\]
\end{simpleexample}

The automaton is \defword{deterministic} (a DFA) iff $\Delta$ is a subset of a function $Q \times \Sigma \rightarrow Q$. I.e., for every state $q \in Q$ and every $a \in \Sigma$, the following state is determined by $\Delta$ or not defined. In that case, we often call the partly-defined function $\delta$ and we write
\[ \A = (Q, \Sigma, q_0, \delta, F). \]

\begin{simpleexample}
\label{reg:dfa-example-1}
The following deterministic automaton is in some way (as defined later) equivalent to the non-deterministic automaton from \cref{reg:nfa-example-1}:
\[
  \begin{tikzpicture}[%
    >=stealth,
	shorten >=1pt,
	node distance=2cm,
    auto,
  ]
    \node[state] (0)              {$0$};
    \node[state] (1) [right of=0] {$1$};
    \node[state] (2) [right of=1] {$2$};
    \node[state,double] (3) [right of=2] {$3$};

    \path[->]
    (0) +(-1.5,0) edge (0)
    (0) edge node {$a$} (1)
    (1) edge [loop above] node {$a$} ()
    (1) edge [bend left] node {$b$} (2)
    (2) edge node {$a$} (1)
    (2) edge node {$b$} (3)
    (3) edge [loop above] node {$b$} ()
    (3) edge [bend left] node {$a$} (1)
    ;
  \end{tikzpicture}
\]
\end{simpleexample}

Note that in many cases, as also in \cref{reg:dfa-example-1}, $\delta$ is only a strict subset of a function, i.e. it is not defined on the whole set $Q \times \Sigma$. We call $\A$ \defword{complete}, if $\Delta$/$\delta$ is defined everywhere, i.e. for every state and input symbol, there is a transition defined. If it is not, we can easily extend $\A$ by an additional state, as can be seen in the following example:
\begin{simpleexample}
\label{reg:dfa-example-2}
The automaton from \cref{reg:dfa-example-1} is not complete. This is a complete version of the same automaton:
\[
  \begin{tikzpicture}[%
    >=stealth,
	shorten >=1pt,
	node distance=2cm,
    auto,
  ]
    \node[state] (0)              {$0$};
    \node[state] (1) [right of=0] {$1$};
    \node[state] (2) [right of=1] {$2$};
    \node[state,double] (3) [right of=2] {$3$};
    \node[state] (4) [below of=0] {$4$};

    \path[->]
    (0) +(-1.5,0) edge (0)
    (0) edge node {$a$} (1)
    (0) edge node {$b$} (4)
    (4) edge [loop right] node {$a,b$} ()
    (1) edge [loop above] node {$a$} ()
    (1) edge [bend left] node {$b$} (2)
    (2) edge node {$a$} (1)
    (2) edge node {$b$} (3)
    (3) edge [loop above] node {$b$} ()
    (3) edge [bend left] node {$a$} (1)
    ;
  \end{tikzpicture}
\]
\end{simpleexample}

Note that we also sometimes have multiple initial states, in which case the automaton is also non-deterministic. Also, in the non-deterministic case, the transition can actual be $\Delta \subseteq Q \times \Sigma^* \times Q$. However, such more generic automaton can be reduced to the definition given here as can be seen in the literature.

Two transitions $(p,a,q), (p',a',q') \in \Delta$ are \defword{consecutive} iff $q=p'$.

A \defword{run} in the automaton $\A$ is a finite sequence of consecutive transitions, written as:
\[ q_0 \xrightarrow{a_0} q_1 \xrightarrow{a_1} q_2 \cdots \]

An automaton $\A = (Q, \Sigma, q_0, \Delta, F)$ \defword{accepts} a finite word $w = (a_0,a_1,\dots,a_n) \in \Sigma^*$ iff there is a run $\rho := q_0 \xrightarrow{a_0} q_1 \xrightarrow{a_1} q_2 \cdots \xrightarrow{a_n} q_{n+1}$ with $q_{n+1} \in F$. We say that the run $\rho$ \defword{matches} the word $w$. We say that the run is an \defword{accepting run}.

The $*$-language $L^*(\A)$ is defined as set of all finite words which are accepted by $\A$.

\begin{simpleexample}
Let $\Sigma = \Set{a,b}$. Let $\A_1 = (Q_1,\Sigma,0,\Delta_1,F_1)$ be the automaton from \cref{reg:nfa-example-1}, $\A_2 = (Q_2,\Sigma,0,\delta_2,F_2)$ be the automaton from \cref{reg:dfa-example-1} and $\A_3 = (Q_3,\Sigma,0,\delta_3,F_3)$ be the automaton from \cref{reg:dfa-example-2}.

For the finite word $w_1 := aabb \in \Sigma^*$, there are three possible runs in $\A_1$:
\begin{enumerate}
\item $0 \xrightarrow{a} 1 \xrightarrow{a} 1 \xrightarrow{b} 1 \xrightarrow{b} 1$
\item $0 \xrightarrow{a} 1 \xrightarrow{a} 1 \xrightarrow{b} 1 \xrightarrow{b} 2$
\item $0 \xrightarrow{a} 1 \xrightarrow{a} 1 \xrightarrow{b} 2 \xrightarrow{b} 3$
\end{enumerate}
The third run is an accepting run because $3 \in F_1$. The other two runs are not accepting. Because there is an accepting run, $w_1 \in L^*(\A_1)$.

In $\A_2$ and $\A_3$, $w_1$ has the deterministic run $0 \xrightarrow{a} 1 \xrightarrow{a} 1 \xrightarrow{b} 2 \xrightarrow{b} 3$. Thus, $w_1 \in L^*(\A_2)$ and $w_1 \in L^*(\A_3)$.

The word $w_2 := aa \in \Sigma^*$ has the only run $0 \xrightarrow{a} 1 \xrightarrow{a} 1$ in $\A_1$, $\A_2$ and $\A_3$. Thus, $w_2 \not\in L^*(\A_1) \cup L^*(\A_2) \cup L^*(\A_3)$.

The word $w_3 := ba \in \Sigma^*$ has no run at all in $\A_1$ and $\A_2$. This demonstrates that $\A_1$ and $\A_2$ are not complete. Thus, $w_2 \not\in L^*(\A_1) \cup L^*(\A_2)$. However, it has the run $0 \xrightarrow{b} 4 \xrightarrow{a} 4$ in $\A_3$. This run doesn't end in an accepting state and there aren't any other runs because $\A_3$ is deterministic, thus $w_3 \not\in L^*(\A_3)$.

We can see that all automata $\A_1$, $\A_2$ and $\A_3$ accept exactly the same words, i.e. the same language. In that sense, they are equivalent.

Informally, they all accept the language of words which start with $a$ and end with $bb$.

A representing regular expression is $a(a+b)^*bb$.
\end{simpleexample}

The class of $*$-languages accepted by a NFA is called $\Lang^*(\text{NFA})$. Likewise, $\Lang^*(\text{DFA})$ is the set of $*$-languages accepted by a DFA. A basic result (see for example \cite{FinAutLogR109} or \cite{InfWordsR110}) is
\[ \Lang^*(\text{DFA}) = \Lang^*(\text{NFA}) = \Lang^*(\text{RE}) . \]
This class of $*$-languages is called the class of \defword{regular $*$-languages}. We call it $\Langreg$ from now on.

Historically, S.C. Kleene proved in \cite{Kleene56} that $\Lang^*(\text{DFA}) = \Lang^*(\text{RE}) $ and it was shown in \cite{FinAutRabin59} by M. O. Rabin and D. Scott that $\Lang^*(\text{DFA}) = \Lang^*(\text{NFA})$. They also gave an effective procedure to turn a NFA into a DFA, namely the well-known powerset construction. In \cite{DFAMinMoore56}, it was shown that there is an (up to isomorphism) minimal DFA for a language and an algorithm to construct it. This property is nice and powerful because we have a canonical minimal DFA for a given regular language. As we mostly deal with subsets of $\Langreg$ in the rest of this thesis, this minimal DFA is useful in some proofs or definitions as we will see later.



\subsection{The class of regular $\omega$-languages}
\label{reg-omega-lang}

The class of regular $\omega$-languages can be defined in many different ways. We will use one common definition and show some equivalent descriptions.
\[ \LangOreg := \Set{ \bigcup_{i=1}^n\ U_i \cdot V_i^\omega }{ U_i, V_i \in \Langreg, n \in \N_0 } \]

This is also called the \defword{$\omega$-Kleene closure} of regular languages.

\subsubsection{$\omega$ regular expressions}

For a regular expression $r$ representing a $*$-language $R\subseteq \Sigma^*$, we can introduce a corresponding $\omega$ regular expression $r^\omega$ which represents the $\omega$-language $R^\omega$. This $\omega$ regular expression can be combined with other $\omega$ regular expressions as usual (via union, intersection and complement) and prefixed by standard regular expressions. We call all these combinations $\omega$ regular expressions.

We see that $\LangOreg$ is closed under union (obviously from the definition), intersection and complement.

Thus, the class of languages accepted by $\omega$ regular expressions is exactly $\LangOreg$.


\subsubsection{$\omega$-automata}

A different, very common description is in terms of automata.

An automaton $\A = (Q, \Sigma, q_0, \Delta, F)$ \defword{Büchi-accepts} an infinite word $\alpha = (a_0,a_1,a_2,...) \in \Sigma^\omega$ iff there is an infinite run $q_0 \xrightarrow{a_0} q_1 \xrightarrow{a_1} q_2 \xrightarrow{a_2} q_3 \cdots$ in $\A$ with $\Set{ i \in \N_0 }{ q_i \in F }$ infinite, i.e. which reaches a state in $F$ infinitely often.

The language $L^\omega(\A)$ is defined as the set of all infinite words which are Büchi-accepted by  $\A$. To make clear that we use the Büchi acceptance condition, we sometimes will also write $L^\omega_\text{Büchi}(\A)$.

A basic result of the study of this language class is: The set of all languages accepted by a non-deterministic Büchi automaton is exactly $\LangOreg$ (see \cite{InfCompR101} or others). %S218
Deterministic Büchi automata are strictly less powerful, e.g. they cannot recognise the language $(a+b)^* b^\omega$.

There are some different forms of $\omega$-automata which differ in their acceptance condition. Noteable are the \defword{Muller condition}, the \defword{Rabin condition}, the \defword{Streett condition} and the \defword{Parity condition}. With such an acceptance condition, we call it \defword{Muller automaton}, etc. The \emph{main theorem of $\omega$-automata} states:
\begin{itemize}
\item Non-deterministic Büchi automata,
\item a boolean combination of deterministic Büchi automata,
\item deterministic Muller automata,
\item deterministic Rabin automata,
\item deterministic Streett automata,
\item deterministic Parity automata
\end{itemize}
all recognize the same class of languages. See \cite{InfCompR101}, \cite{LangAutLogicR102}, \cite{InfWordsR110} and others. The main part of this theorem is \defword{McNaughton's Theorem} which states the equivalence of non-deterministic Büchi automata and deterministic Muller automata.
%S407

Muller automata are interesting for us in the rest of this thesis. The acceptance component of a Muller automaton is a set $\F \subseteq 2^Q$, also called the \defword{table} of the automaton (instead of a single set $F \subseteq Q$). A word $w \in \Sigma^\omega$ is accepted iff there is an infinite run $\rho$ with $\Inf(\rho) \in \F$, where $\Inf(\rho)$ is the set of infinitely often reached states of the run $\rho$.

We write:
\[ \A = (Q, \Sigma, q_0, \Delta, \F) . \]

\subsubsection{Language operators}
\label{reg:omega:vialangop}

Büchi acceptance is closely connected to the language operator
\[ \lim(L) := \Set{ \alpha \in \Sigma^\omega }{ \existsinf n \colon \alpha[0,n] \in L } . \]
We define the language class operator
\[ \lim(\Lang) := \Set{\lim(L)}{L \in \Lang} . \]
We see that $\lim(\Langreg)$ is equal to the languages accepted by deterministic Büchi automata (\cite{InfCompR101}). %S407
I.e.
\[ \lim \Langreg = \Set{L^\omega_\text{Büchi}(\A)}{\text{$\A$ is det. Büchi automaton}} . \]
Thus,
\[  \BC \lim \Langreg = \LangOreg , \]
where $\BC \mathcal{X}$ is defined as all \defword{boolean combinations} (union, intersection, complement) from $\mathcal{X}$. Formally: $\BC$ is defined as a function
\[ \BC \colon \Power(\mathcal{W}) \rightarrow \Power(\mathcal{W}) \]
where $\mathcal{W}$ is usually $\Power(\Sigma^\omega)$. Then, $\BC(\mathcal{X})$ is defined as the smallest set with
\begin{itemize}
\item $\mathcal{X} \subseteq \BC \mathcal{X}$,
\item $-X \in \BC \mathcal{X}$ for all $X \in \BC \mathcal{X}$,
\item $X_1 \cup X_2 \in \BC \mathcal{X}$ for all $X_1,X_2 \in \BC \mathcal{X}$,
\item $X_1 \cap X_2 \in \BC \mathcal{X}$ for all $X_1,X_2 \in \BC \mathcal{X}$.
\end{itemize}
$\mathcal{W}$ is always determined from the context. We normally have $\mathcal{W} = \Power(\Sigma^\omega)$, i.e. the set of all $\omega$-languages. Then, $\BC$ is an operator on $\omega$-language classes. We could also have $\mathcal{W} = \Power(\Sigma^*)$, then $\BC$ would be an operator on $*$-language classes. Note that we never have $\mathcal{W} = \Power(\Sigma^* \cup \Sigma^\omega)$ in this thesis. This note is important as the $\BC$ operator would be ambiguous otherwise.

% TODO: ref
Another classification is
\[ \LangOreg = \Set{ \bigcup_{i=0}^n U_i \cdot \lim V_i }{ U_i, V_i \in \Langreg, n \in \N_0 } . \]

\subsubsection{Logic on infinite words}
% TODO: more
%(S218,S411,R107)
Let $L_2(\Sigma)$ be the set of formulas $\operatorname{MSO}(<)$ over $\Sigma$. The interpretation of such formulas over infinite words is straight-forward. In \cite[Theorem 3.1]{CombR107}, we can see that
\[ \LangOreg = \Set{A \subseteq \Sigma^\omega}{A \text{ definable in } L_2(\Sigma)} . \]
% in R107, similar/same thing for Langreg
% In \cite[]{FinAutLogR109}, SOM[+1]

\subsubsection{Some properties}

\begin{lemma}
\label{reg:limRegClosedIntersection}
$\lim \Langreg$ is closed under intersection.
\begin{proof}
In \cite[Chapter 12, Remark 12.4]{CAVR112}, this is shown via a special product automata construction of deterministic Büchi automata.
% one proof, via product automata, would be in http://mtc.epfl.ch/courses/CAV_WS2004/12.pdf
% other sources?
\end{proof}
\end{lemma}
